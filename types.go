package go2webrpc

import (
	"fmt"
	"go/types"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/pkg/errors"
	"github.com/webrpc/webrpc/schema"
)

// Given `db:"id,omitempty,pk" json:"id,string"` struct tag,
// this regex will return the following three submatches:
// [0]: json:"id,string"
// [1]: id
// [2]: ,string
var jsonTagRegex, _ = regexp.Compile(`\s?json:\"([^,\"]*)(,[^\"]*)?\"`)

func (p *parser) parseType(typ types.Type) (*schema.VarType, error) {
	return p.parseNamedType("", typ)
}

func (p *parser) getTypeName(typ types.Type) string {
	name := typ.String()       // []github.com/golang-cz/go2webrpc/pkg.Typ
	name = filepath.Base(name) // pkg.Typ

	pkgName, typName, _ := strings.Cut(name, ".")
	if pkgName == p.schemaPkgName || pkgName == "command-line-arguments" {
		// Ignore root schema package name.
		// Ignore "command-line-arguments" package path autogenerated by Go tool chain.
		return strings.ToLower(typName[:1]) + typName[1:]
	}

	return pkgName + typName
}

func (p *parser) parseNamedType(typeName string, typ types.Type) (varType *schema.VarType, err error) {
	// Return an already parsed type from cache.
	if parsedType, ok := p.parsedTypes[typ]; ok {
		return parsedType, nil
	}

	// Otherwise, create a new parsedType record in cache (claim the cache key)
	// and fill in the value. Meanwhile, any following recursive call(s) to this
	// function (ie. on recursive types like self-referencing structs, linked
	// lists, graphs, circular dependencies etc.) will return the same pointer
	// from cache.
	// Note: We're parsing sequentially, no need for sync.Map.

	// Warm up the cache up-front. We fill in the cache value in defer()
	// from the actual return value (varType).
	cacheDoNotReturn := &schema.VarType{
		Expr: typeName,
	}
	p.parsedTypes[typ] = cacheDoNotReturn

	defer func() {
		if varType != nil {
			*cacheDoNotReturn = *varType // Update the cache value via a pointer dereference.
			varType = cacheDoNotReturn
		}
	}()

	switch v := typ.(type) {
	case *types.Named:
		underlying := v.Underlying()

		switch u := underlying.(type) {
		// TODO: Aliases?

		case *types.Pointer:
			// Named pointer. Webrpc can't handle that.
			// Example:
			//   `type NamedPtr *Obj`

			// Go for the underlying element type name (ie. `Obj`).
			return p.parseNamedType(p.getTypeName(underlying), u.Underlying())

		case *types.Slice:
			// Named slice. Webrpc can't handle that.
			// Example:
			//  `type NamedSlice []int`
			//  `type NamedSlice []Obj`

			// If the underlying element type is basic (ie. `int`), we don't
			// want to name it in webrpc. Go for the basic type directly.
			elem := u.Elem().Underlying()
			if basic, ok := elem.(*types.Basic); ok {
				return p.parseBasic(basic)
			}

			// Otherwise, go for the underlying element type name (ie. `Obj`).
			return p.parseNamedType(p.getTypeName(underlying), u.Underlying())
		}

		pkg := v.Obj().Pkg()
		if pkg == nil {
			return p.parseNamedType(typeName, underlying)
		}

		typeName := p.getTypeName(typ)

		// Does the type satisfy encoding.TextMarshaller and encoding.TextUnmarshaler interfaces?
		// Then its value is always rendered as a quoted string in JSON encoding. Return string.
		// TODO: Actually.. should this be `any`?
		marshalTextMethod, _, _ := types.LookupFieldOrMethod(v, true, pkg, "MarshalText")
		unmarshalTextMethod, _, _ := types.LookupFieldOrMethod(v, true, pkg, "UnmarshalText")
		if marshalTextMethod != nil && unmarshalTextMethod != nil &&
			strings.HasSuffix(marshalTextMethod.String(), ".MarshalText() ([]byte, error)") &&
			strings.HasSuffix(unmarshalTextMethod.String(), ".UnmarshalText(text []byte) error") {
			var v schema.VarType
			if err := schema.ParseVarTypeExpr(p.schema, "string", &v); err != nil {
				return nil, errors.Wrap(err, "failed to parse string")
			}
			return &v, nil
		}

		if pkg.Path() == "time" && typeName == "timeTime" {
			var v schema.VarType
			if err := schema.ParseVarTypeExpr(p.schema, "timestamp", &v); err != nil {
				return nil, errors.Wrap(err, "failed to parse timestamp")
			}
			return &v, nil
		}

		return p.parseNamedType(typeName, underlying)

	case *types.Basic:
		return p.parseBasic(v)

	case *types.Struct:
		return p.parseStruct(typeName, v)

	case *types.Slice:
		return p.parseSlice(typeName, v)

	case *types.Interface:
		return p.parseInterface(typeName, v)

	case *types.Map:
		return p.parseMap(typeName, v)

	case *types.Pointer:
		if typeName == "" {
			underlyingTypeName := v.String()                                     // *github.com/golang-cz/go2webrpc/pkg.Obj
			underlyingTypeName = filepath.Base(underlyingTypeName)               // pkg.Obj
			underlyingTypeName = strings.ReplaceAll(underlyingTypeName, ".", "") // pkgObj
			return p.parseNamedType(underlyingTypeName, v.Elem())
		}
		return p.parseNamedType(typeName, v.Elem())

	default:
		return nil, errors.Errorf("unsupported argument type %T", typ)
	}
}

func resolveRenamedTypes(typ types.Type) types.Type {
	for {
		underlying, ok := typ.Underlying().(*types.Named)
		if !ok {
			break
		}
		typ = underlying
	}
	return typ
}

func (p *parser) parseBasic(typ *types.Basic) (*schema.VarType, error) {
	var varType schema.VarType
	if err := schema.ParseVarTypeExpr(p.schema, typ.Name(), &varType); err != nil {
		return nil, errors.Wrapf(err, "failed to parse basic type: %v", typ.Name())
	}

	return &varType, nil
}

func (p *parser) parseStruct(typeName string, structTyp *types.Struct) (varType *schema.VarType, err error) {
	// typeName is for example "github.com/webrpc/webrpc/schema/VarType"
	// Split by separators & get the shortest possible unique prefixed type name (ie. schemaVarType).
	typeNameParts := strings.FieldsFunc(typeName, func(r rune) bool {
		return r == '.' || r == '/' || r == '-' || r == '_'
	})
	typeName = ""
	for i := len(typeNameParts) - 1; i >= 0; i-- {
		typeName = typeNameParts[i] + typeName
		if _, ok := p.parsedTypeNames[typeName]; !ok {
			p.parsedTypeNames[typeName] = struct{}{}
			break
		}
	}

	msg := &schema.Message{
		Name: schema.VarName(typeName),
		Type: schema.MessageType("struct"),
	}

	for i := 0; i < structTyp.NumFields(); i++ {
		field := structTyp.Field(i)
		if !field.Exported() {
			continue
		}

		tag := structTyp.Tag(i)
		if field.Embedded() || strings.Contains(tag, `json:",inline"`) {
			varType, err := p.parseNamedType("", field.Type())
			if err != nil {
				return nil, errors.Wrapf(err, "failed to parse var %v", field.Name())
			}

			if varType.Type == schema.T_Struct {
				for _, embeddedField := range varType.Struct.Message.Fields {
					msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, embeddedField)
				}
			}
			continue
		}

		optional := false

		fieldName := field.Name()
		if strings.Contains(tag, `json:"`) {
			submatches := jsonTagRegex.FindStringSubmatch(tag)
			// Submatches from the jsonTagRegex:
			// [0]: json:"deleted_by,omitempty,string"
			// [1]: deleted_by
			// [2]: ,omitempty,string
			if len(submatches) != 3 {
				return nil, errors.Errorf("unexpected number of json struct tag submatches")
			}
			if submatches[1] == "-" { // suppressed field in JSON struct tag
				continue
			}
			if submatches[1] != "" { // field name defined in JSON struct tag
				fieldName = submatches[1]
			}
			optional = strings.Contains(submatches[2], ",omitempty")
			if strings.Contains(submatches[2], ",string") { // field type should be string in JSON
				msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, &schema.MessageField{
					Name: schema.VarName(fieldName),
					Type: &schema.VarType{
						Expr: "string",
						Type: schema.T_String,
					},
					Optional: optional,
				})
				continue
			}
		}

		if _, ok := field.Type().Underlying().(*types.Pointer); ok {
			optional = true
		}

		typeName := ""
		if _, ok := field.Type().Underlying().(*types.Struct); ok {
			// TODO: Anonymous struct fields. Example:
			//
			// type Something struct {
			// 	 AnonymousField struct { // ==> this struct doesn't have type name since it's an anonymous struct, let's make it "SomethingAnonymousField"
			//     Name string
			//   }
			// }
			typeName = typeName + strings.ToTitle(fieldName[:1]) + fieldName[1:]
		}

		varType, err := p.parseNamedType(typeName, field.Type())
		if err != nil {
			return nil, errors.Wrapf(err, "failed to parse var %v", field.Name())
		}

		msg.Fields = appendMessageFieldAndDeleteExisting(msg.Fields, &schema.MessageField{
			Name:     schema.VarName(fieldName),
			Type:     varType,
			Optional: optional,
		})
	}

	p.schema.Messages = append(p.schema.Messages, msg)

	return &schema.VarType{
		Expr: typeName,
		Type: schema.T_Struct,
		Struct: &schema.VarStructType{
			Name:    typeName,
			Message: msg,
		},
	}, nil
}

// Appends message field to the given slice, while also removing any previously defined field of the same name.
// This lets us overwrite embedded fields, exactly how Go does it behind the scenes in the JSON marshaller.
func appendMessageFieldAndDeleteExisting(slice []*schema.MessageField, newItem *schema.MessageField) []*schema.MessageField {
	// Let's try to find an existing item of the same name and delete it.
	for i, item := range slice {
		if item.Name == newItem.Name {
			// Delete item.
			copy(slice[i:], slice[i+1:])
			slice = slice[:len(slice)-1]
		}
	}
	// And then append the new item at the end of the slice.
	return append(slice, newItem)
}

func (p *parser) parseSlice(typeName string, sliceTyp *types.Slice) (*schema.VarType, error) {
	elem, err := p.parseNamedType(typeName, sliceTyp.Elem())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse slice type")
	}

	actualTypeName := typeName
	if actualTypeName == "" {
		actualTypeName = elem.String()
	}

	varType := &schema.VarType{
		Expr: fmt.Sprintf("[]%v", actualTypeName),
		Type: schema.T_List,
		List: &schema.VarListType{
			Elem: elem,
		},
	}

	return varType, nil
}

func (p *parser) parseInterface(typeName string, iface *types.Interface) (*schema.VarType, error) {
	// TODO: A special case for error and context.Context.

	varType := &schema.VarType{
		Expr: "any",
		Type: schema.T_Any,
	}

	return varType, nil
}

func (p *parser) parseMap(typeName string, m *types.Map) (*schema.VarType, error) {
	key, err := p.parseNamedType(typeName, m.Key())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse map key type")
	}

	value, err := p.parseNamedType(typeName, m.Elem())
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse map value type")
	}

	varType := &schema.VarType{
		Expr: fmt.Sprintf("map<%v,%v>", key, value),
		Type: schema.T_Map,
		Map: &schema.VarMapType{
			Key:   key.Type,
			Value: value,
		},
	}

	return varType, nil
}
